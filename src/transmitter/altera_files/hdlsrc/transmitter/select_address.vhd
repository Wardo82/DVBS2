-- -------------------------------------------------------------
-- 
-- File Name: /home/wardo/Documents/DVBS2/DVBS2/src/transmitter/altera_files/hdlsrc/transmitter/select_address.vhd
-- Created: 2021-02-07 15:24:31
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: select_address
-- Source Path: transmitter/tran_dut/ldpc_encoder/select_address
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.tran_dut_pac.ALL;

ENTITY select_address IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb_1_8_1                         :   IN    std_logic;
        addresses                         :   IN    vector_of_std_logic_vector14(0 TO 11);  -- ufix14 [12]
        a1                                :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
        a2                                :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
        a3                                :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
        a4                                :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
        a5                                :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
        a6                                :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
        a7                                :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
        a8                                :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
        a9                                :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
        a10                               :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
        a11                               :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
        a12                               :   OUT   std_logic_vector(13 DOWNTO 0)  -- ufix14
        );
END select_address;


ARCHITECTURE rtl OF select_address IS

  ATTRIBUTE multstyle : string;

  -- Signals
  SIGNAL addresses_unsigned               : vector_of_unsigned14(0 TO 11);  -- ufix14 [12]
  SIGNAL a1_1                             : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a2_1                             : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a3_1                             : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a4_1                             : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a5_1                             : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a6_1                             : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a7_1                             : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a8_1                             : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a9_1                             : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a10_1                            : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a11_1                            : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a12_1                            : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL Switch2_bypass_reg               : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a1_tmp                           : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL Switch3_bypass_reg               : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a2_tmp                           : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL Switch4_bypass_reg               : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a3_tmp                           : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL Switch5_bypass_reg               : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a4_tmp                           : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL Switch6_bypass_reg               : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a5_tmp                           : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL Switch7_bypass_reg               : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a6_tmp                           : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL Switch8_bypass_reg               : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a7_tmp                           : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL Switch9_bypass_reg               : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a8_tmp                           : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL Switch10_bypass_reg              : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a9_tmp                           : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL Switch11_bypass_reg              : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a10_tmp                          : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL Switch12_bypass_reg              : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a11_tmp                          : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL Switch13_bypass_reg              : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL a12_tmp                          : unsigned(13 DOWNTO 0);  -- ufix14

BEGIN
  outputgen: FOR k IN 0 TO 11 GENERATE
    addresses_unsigned(k) <= unsigned(addresses(k));
  END GENERATE;

  a1_1 <= addresses_unsigned(0);
  a2_1 <= addresses_unsigned(1);
  a3_1 <= addresses_unsigned(2);
  a4_1 <= addresses_unsigned(3);
  a5_1 <= addresses_unsigned(4);
  a6_1 <= addresses_unsigned(5);
  a7_1 <= addresses_unsigned(6);
  a8_1 <= addresses_unsigned(7);
  a9_1 <= addresses_unsigned(8);
  a10_1 <= addresses_unsigned(9);
  a11_1 <= addresses_unsigned(10);
  a12_1 <= addresses_unsigned(11);

  Switch2_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Switch2_bypass_reg <= to_unsigned(16#0000#, 14);
      ELSIF enb_1_8_1 = '1' THEN
        Switch2_bypass_reg <= a1_1;
      END IF;
    END IF;
  END PROCESS Switch2_bypass_process;

  
  a1_tmp <= a1_1 WHEN enb_1_8_1 = '1' ELSE
      Switch2_bypass_reg;

  a1 <= std_logic_vector(a1_tmp);

  Switch3_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Switch3_bypass_reg <= to_unsigned(16#0000#, 14);
      ELSIF enb_1_8_1 = '1' THEN
        Switch3_bypass_reg <= a2_1;
      END IF;
    END IF;
  END PROCESS Switch3_bypass_process;

  
  a2_tmp <= a2_1 WHEN enb_1_8_1 = '1' ELSE
      Switch3_bypass_reg;

  a2 <= std_logic_vector(a2_tmp);

  Switch4_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Switch4_bypass_reg <= to_unsigned(16#0000#, 14);
      ELSIF enb_1_8_1 = '1' THEN
        Switch4_bypass_reg <= a3_1;
      END IF;
    END IF;
  END PROCESS Switch4_bypass_process;

  
  a3_tmp <= a3_1 WHEN enb_1_8_1 = '1' ELSE
      Switch4_bypass_reg;

  a3 <= std_logic_vector(a3_tmp);

  Switch5_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Switch5_bypass_reg <= to_unsigned(16#0000#, 14);
      ELSIF enb_1_8_1 = '1' THEN
        Switch5_bypass_reg <= a4_1;
      END IF;
    END IF;
  END PROCESS Switch5_bypass_process;

  
  a4_tmp <= a4_1 WHEN enb_1_8_1 = '1' ELSE
      Switch5_bypass_reg;

  a4 <= std_logic_vector(a4_tmp);

  Switch6_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Switch6_bypass_reg <= to_unsigned(16#0000#, 14);
      ELSIF enb_1_8_1 = '1' THEN
        Switch6_bypass_reg <= a5_1;
      END IF;
    END IF;
  END PROCESS Switch6_bypass_process;

  
  a5_tmp <= a5_1 WHEN enb_1_8_1 = '1' ELSE
      Switch6_bypass_reg;

  a5 <= std_logic_vector(a5_tmp);

  Switch7_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Switch7_bypass_reg <= to_unsigned(16#0000#, 14);
      ELSIF enb_1_8_1 = '1' THEN
        Switch7_bypass_reg <= a6_1;
      END IF;
    END IF;
  END PROCESS Switch7_bypass_process;

  
  a6_tmp <= a6_1 WHEN enb_1_8_1 = '1' ELSE
      Switch7_bypass_reg;

  a6 <= std_logic_vector(a6_tmp);

  Switch8_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Switch8_bypass_reg <= to_unsigned(16#0000#, 14);
      ELSIF enb_1_8_1 = '1' THEN
        Switch8_bypass_reg <= a7_1;
      END IF;
    END IF;
  END PROCESS Switch8_bypass_process;

  
  a7_tmp <= a7_1 WHEN enb_1_8_1 = '1' ELSE
      Switch8_bypass_reg;

  a7 <= std_logic_vector(a7_tmp);

  Switch9_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Switch9_bypass_reg <= to_unsigned(16#0000#, 14);
      ELSIF enb_1_8_1 = '1' THEN
        Switch9_bypass_reg <= a8_1;
      END IF;
    END IF;
  END PROCESS Switch9_bypass_process;

  
  a8_tmp <= a8_1 WHEN enb_1_8_1 = '1' ELSE
      Switch9_bypass_reg;

  a8 <= std_logic_vector(a8_tmp);

  Switch10_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Switch10_bypass_reg <= to_unsigned(16#0000#, 14);
      ELSIF enb_1_8_1 = '1' THEN
        Switch10_bypass_reg <= a9_1;
      END IF;
    END IF;
  END PROCESS Switch10_bypass_process;

  
  a9_tmp <= a9_1 WHEN enb_1_8_1 = '1' ELSE
      Switch10_bypass_reg;

  a9 <= std_logic_vector(a9_tmp);

  Switch11_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Switch11_bypass_reg <= to_unsigned(16#0000#, 14);
      ELSIF enb_1_8_1 = '1' THEN
        Switch11_bypass_reg <= a10_1;
      END IF;
    END IF;
  END PROCESS Switch11_bypass_process;

  
  a10_tmp <= a10_1 WHEN enb_1_8_1 = '1' ELSE
      Switch11_bypass_reg;

  a10 <= std_logic_vector(a10_tmp);

  Switch12_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Switch12_bypass_reg <= to_unsigned(16#0000#, 14);
      ELSIF enb_1_8_1 = '1' THEN
        Switch12_bypass_reg <= a11_1;
      END IF;
    END IF;
  END PROCESS Switch12_bypass_process;

  
  a11_tmp <= a11_1 WHEN enb_1_8_1 = '1' ELSE
      Switch12_bypass_reg;

  a11 <= std_logic_vector(a11_tmp);

  Switch13_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Switch13_bypass_reg <= to_unsigned(16#0000#, 14);
      ELSIF enb_1_8_1 = '1' THEN
        Switch13_bypass_reg <= a12_1;
      END IF;
    END IF;
  END PROCESS Switch13_bypass_process;

  
  a12_tmp <= a12_1 WHEN enb_1_8_1 = '1' ELSE
      Switch13_bypass_reg;

  a12 <= std_logic_vector(a12_tmp);

END rtl;

