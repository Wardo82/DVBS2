-- -------------------------------------------------------------
-- 
-- File Name: /home/wardo/Documents/DVBS2/DVBS2/src/transmitter/3-FEC/interleaver/generic_files/hdlsrc/interleaver_model/interleaver.vhd
-- Created: 2021-02-05 06:38:03
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: interleaver
-- Source Path: interleaver_model/interleaver_dut/interleaver
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.interleaver_dut_pac.ALL;

ENTITY interleaver IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        input_bit                         :   IN    std_logic;
        start                             :   IN    std_logic;
        data                              :   OUT   std_logic_vector(2 DOWNTO 0);  -- ufix3
        valid                             :   OUT   std_logic
        );
END interleaver;


ARCHITECTURE rtl OF interleaver IS

  -- Signals
  SIGNAL data_tmp                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL moore_state_reg                  : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL counter                          : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL column                           : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL buffer_rsvd                      : vector_of_unsigned3(0 TO 21599);  -- ufix3 [21600]
  SIGNAL moore_state_reg_next             : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL counter_next                     : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL column_next                      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL buffer_next                      : vector_of_unsigned3(0 TO 21599);  -- ufix3 [21600]

BEGIN
  interleaver_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        moore_state_reg <= to_unsigned(16#0#, 2);
        counter <= to_unsigned(16#0001#, 16);
        column <= to_unsigned(16#3#, 3);
        buffer_rsvd <= (OTHERS => to_unsigned(16#0#, 3));
      ELSIF enb = '1' THEN
        moore_state_reg <= moore_state_reg_next;
        counter <= counter_next;
        column <= column_next;
        buffer_rsvd <= buffer_next;
      END IF;
    END IF;
  END PROCESS interleaver_1_process;

  interleaver_1_output : PROCESS (buffer_rsvd, column, counter, input_bit, moore_state_reg, start)
    VARIABLE c : unsigned(2 DOWNTO 0);
    VARIABLE bit_idx : unsigned(7 DOWNTO 0);
    VARIABLE mask : unsigned(2 DOWNTO 0);
    VARIABLE counter_temp : unsigned(15 DOWNTO 0);
    VARIABLE column_temp : unsigned(2 DOWNTO 0);
    VARIABLE buffer_temp : vector_of_unsigned3(0 TO 21599);
    VARIABLE c_0 : unsigned(2 DOWNTO 0);
    VARIABLE sub_cast : signed(31 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(31 DOWNTO 0);
    VARIABLE sub_cast_1 : signed(31 DOWNTO 0);
    VARIABLE sub_cast_2 : signed(31 DOWNTO 0);
  BEGIN
    bit_idx := to_unsigned(16#00#, 8);
    c_0 := to_unsigned(16#0#, 3);
    c := to_unsigned(16#0#, 3);
    mask := to_unsigned(16#0#, 3);
    sub_cast := to_signed(16#00000000#, 32);
    sub_cast_0 := to_signed(16#00000000#, 32);
    sub_cast_1 := to_signed(16#00000000#, 32);
    sub_cast_2 := to_signed(16#00000000#, 32);
    counter_temp := counter;
    column_temp := column;
    buffer_temp := buffer_rsvd;
    moore_state_reg_next <= moore_state_reg;
    CASE moore_state_reg IS
      WHEN "00" =>
        counter_temp := to_unsigned(16#0001#, 16);
        column_temp := to_unsigned(16#3#, 3);
        buffer_temp := (OTHERS => to_unsigned(16#0#, 3));
        valid <= '0';
        data_tmp <= to_unsigned(16#0#, 3);
        IF ( NOT start) = '1' THEN 
          moore_state_reg_next <= to_unsigned(16#0#, 2);
        ELSE 
          moore_state_reg_next <= to_unsigned(16#1#, 2);
          -- Write first bit at the first position as it is the MSB
          IF input_bit = '1' THEN 
            c_0 := buffer_temp(0) OR to_unsigned(16#4#, 3);
          ELSE 
            c_0 := buffer_temp(0) AND to_unsigned(16#3#, 3);
          END IF;
          buffer_temp(0) := c_0;
          counter_temp := to_unsigned(16#0002#, 16);
        END IF;
      WHEN "01" =>
        IF (column >= to_unsigned(16#1#, 3)) AND (column <= to_unsigned(16#3#, 3)) THEN 
          bit_idx := resize(column, 8) + 255;
          mask := to_unsigned(16#1#, 3) sll to_integer(bit_idx);
          IF input_bit = '1' THEN 
            sub_cast_2 := signed(resize(counter, 32));
            c := buffer_rsvd(to_integer(sub_cast_2 - 1)) OR mask;
          ELSE 
            sub_cast_1 := signed(resize(counter, 32));
            c := buffer_rsvd(to_integer(sub_cast_1 - 1)) AND ( NOT mask);
          END IF;
        END IF;
        sub_cast_0 := signed(resize(counter, 32));
        buffer_temp(to_integer(sub_cast_0 - 1)) := c;
        counter_temp := counter + to_unsigned(16#0001#, 16);
        IF counter_temp > to_unsigned(16#5460#, 16) THEN 
          counter_temp := to_unsigned(16#0001#, 16);
          column_temp := column - to_unsigned(16#1#, 3);
          IF column_temp = to_unsigned(16#0#, 3) THEN 
            moore_state_reg_next <= to_unsigned(16#2#, 2);
            column_temp := to_unsigned(16#1#, 3);
            valid <= '1';
            data_tmp <= buffer_temp(0);
            counter_temp := to_unsigned(16#0002#, 16);
          ELSE 
            data_tmp <= to_unsigned(16#0#, 3);
            valid <= '0';
          END IF;
        ELSE 
          valid <= '0';
          data_tmp <= to_unsigned(16#0#, 3);
        END IF;
      WHEN "10" =>
        sub_cast := signed(resize(counter, 32));
        data_tmp <= buffer_rsvd(to_integer(sub_cast - 1));
        counter_temp := counter + to_unsigned(16#0001#, 16);
        IF counter_temp > to_unsigned(16#5460#, 16) THEN 
          moore_state_reg_next <= to_unsigned(16#0#, 2);
        END IF;
        valid <= '1';
      WHEN OTHERS => 
        valid <= '0';
        data_tmp <= to_unsigned(16#0#, 3);
    END CASE;
    counter_next <= counter_temp;
    column_next <= column_temp;
    buffer_next <= buffer_temp;
  END PROCESS interleaver_1_output;


  data <= std_logic_vector(data_tmp);

END rtl;

