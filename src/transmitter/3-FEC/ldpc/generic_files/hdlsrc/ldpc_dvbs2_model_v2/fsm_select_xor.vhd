-- -------------------------------------------------------------
-- 
-- File Name: D:\Documents\DVBS2\DVBS2\src\transmitter\3-FEC\ldpc\generic_files\hdlsrc\ldpc_dvbs2_model_v2\fsm_select_xor.vhd
-- Created: 2021-02-05 04:55:51
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: fsm_select_xor
-- Source Path: ldpc_dvbs2_model_v2/ldpc_encoder/fsm_select_xor
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ldpc_encoder_pac.ALL;

ENTITY fsm_select_xor IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        parity_in                         :   IN    std_logic_vector(0 TO 16200);  -- ufix1 [16201]
        addresses                         :   IN    vector_of_std_logic_vector16(0 TO 11);  -- uint16 [12]
        input_bit                         :   IN    std_logic;
        enable                            :   IN    std_logic;
        parity_out                        :   OUT   std_logic_vector(0 TO 16200);  -- ufix1 [16201]
        serial_out                        :   OUT   std_logic;  -- ufix1
        valid                             :   OUT   std_logic  -- ufix1
        );
END fsm_select_xor;


ARCHITECTURE rtl OF fsm_select_xor IS

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;

  -- HDLCODER_TO_SIGNED
  FUNCTION hdlcoder_to_signed(arg: boolean; width: integer) RETURN signed IS
  BEGIN
    IF arg THEN
      RETURN to_signed(1, width);
    ELSE
      RETURN to_signed(0, width);
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL addresses_unsigned               : vector_of_unsigned16(0 TO 11);  -- uint16 [12]
  SIGNAL parity_bits                      : std_logic_vector(0 TO 16200);  -- ufix1 [16201]
  SIGNAL moore_state_machine              : std_logic;  -- ufix1
  SIGNAL counter                          : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL parity_bits_next                 : std_logic_vector(0 TO 16200);  -- ufix1 [16201]
  SIGNAL moore_state_machine_next         : std_logic;  -- ufix1
  SIGNAL counter_next                     : unsigned(15 DOWNTO 0);  -- ufix16

BEGIN
  outputgen: FOR k IN 0 TO 11 GENERATE
    addresses_unsigned(k) <= unsigned(addresses(k));
  END GENERATE;

  fsm_select_xor_1_process : PROCESS (clk)
    VARIABLE t_1 : INTEGER;
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN

        FOR t_1 IN 0 TO 16200 LOOP
          parity_bits(t_1) <= '0';
        END LOOP;

        moore_state_machine <= '0';
        counter <= to_unsigned(16#0001#, 16);
      ELSIF enb = '1' THEN

        FOR t_0 IN 0 TO 16200 LOOP
          parity_bits(t_0) <= parity_bits_next(t_0);
        END LOOP;

        moore_state_machine <= moore_state_machine_next;
        counter <= counter_next;
      END IF;
    END IF;
  END PROCESS fsm_select_xor_1_process;

  fsm_select_xor_1_output : PROCESS (addresses_unsigned, counter, enable, input_bit, moore_state_machine,
       parity_bits, parity_in)
    VARIABLE counter_temp : unsigned(15 DOWNTO 0);
    VARIABLE sub_cast : signed(31 DOWNTO 0);
    VARIABLE add_temp : vector_of_unsigned16(0 TO 11);
    VARIABLE sub_cast_0 : vector_of_signed32(0 TO 11);
    VARIABLE add_temp_0 : vector_of_unsigned16(0 TO 11);
    VARIABLE sub_cast_1 : vector_of_signed32(0 TO 11);
    VARIABLE cast : vector_of_signed32(0 TO 11);
    VARIABLE sub_cast_2 : signed(31 DOWNTO 0);
  BEGIN
    sub_cast := to_signed(16#00000000#, 32);
    sub_cast_2 := to_signed(16#00000000#, 32);
    counter_temp := counter;
    moore_state_machine_next <= moore_state_machine;
    --MATLAB Function 'ldpc_encoder/fsm_select_xor'

    FOR t_0 IN 0 TO 16200 LOOP
      parity_bits_next(t_0) <= parity_bits(t_0);
      parity_out(t_0) <= parity_in(t_0);
    END LOOP;

    CASE moore_state_machine IS
      WHEN '0' =>
        serial_out <= '0';
        valid <= '0';

        FOR t_1 IN 0 TO 11 LOOP
          add_temp(t_1) := addresses_unsigned(t_1) + 1;
          sub_cast_0(t_1) := signed(resize(add_temp(t_1), 32));
          add_temp_0(t_1) := addresses_unsigned(t_1) + 1;
          sub_cast_1(t_1) := signed(resize(add_temp_0(t_1), 32));
          cast(t_1) := '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & input_bit;
          parity_out(to_integer(sub_cast_0(t_1) - 1)) <= hdlcoder_to_stdlogic(hdlcoder_to_signed(parity_in(to_integer(sub_cast_1(t_1) - 1)) /= '0', 32) /= cast(t_1));
        END LOOP;

        IF enable = '1' THEN 
          moore_state_machine_next <= '1';

          FOR t_2 IN 0 TO 16200 LOOP
            parity_bits_next(t_2) <= parity_in(t_2);
          END LOOP;

          sub_cast_2 := signed(resize(counter, 32));
          serial_out <= parity_in(to_integer(sub_cast_2 - 1));
          counter_temp := counter + to_unsigned(16#0001#, 16);
          valid <= '1';
        END IF;
      WHEN '1' =>
        sub_cast := signed(resize(counter, 32));
        serial_out <= parity_bits(to_integer(sub_cast - 1));
        counter_temp := counter + to_unsigned(16#0001#, 16);
        valid <= '1';
        IF counter_temp > to_unsigned(16#3F48#, 16) THEN 
          moore_state_machine_next <= '0';
        END IF;
      WHEN OTHERS => 
        serial_out <= '0';
        valid <= '0';
    END CASE;
    counter_next <= counter_temp;
  END PROCESS fsm_select_xor_1_output;


END rtl;

