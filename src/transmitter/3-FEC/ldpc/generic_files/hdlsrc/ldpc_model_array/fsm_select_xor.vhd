-- -------------------------------------------------------------
-- 
-- File Name: /home/wardo/Documents/DVBS2/DVBS2/src/transmitter/3-FEC/ldpc/generic_files/hdlsrc/ldpc_model_array/fsm_select_xor.vhd
-- Created: 2021-02-07 13:53:13
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: fsm_select_xor
-- Source Path: ldpc_model_array/ldpc_encoder/fsm_select_xor
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ldpc_encoder_pac.ALL;

ENTITY fsm_select_xor IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        addresses                         :   IN    vector_of_std_logic_vector16(0 TO 11);  -- uint16 [12]
        input_bit                         :   IN    std_logic;
        start                             :   IN    std_logic;
        enable                            :   IN    std_logic;
        serial_out                        :   OUT   std_logic;  -- ufix1
        valid                             :   OUT   std_logic  -- ufix1
        );
END fsm_select_xor;


ARCHITECTURE rtl OF fsm_select_xor IS

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;

  -- HDLCODER_TO_SIGNED
  FUNCTION hdlcoder_to_signed(arg: boolean; width: integer) RETURN signed IS
  BEGIN
    IF arg THEN
      RETURN to_signed(1, width);
    ELSE
      RETURN to_signed(0, width);
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL tmp                              : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_1                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_2                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_3                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_4                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_5                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_6                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_7                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_8                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_9                            : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL tmp_10                           : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL tmp_11                           : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL counter                          : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL counter_1                        : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL counter_2                        : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL tmp_12                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL tmp_13                           : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL counter_3                        : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL counter_4                        : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL tmp_14                           : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL tmp_16                           : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL tmp_18                           : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL moore_state_machine              : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_20                           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_22                           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_24                           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_26                           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL addresses_unsigned               : vector_of_unsigned16(0 TO 11);  -- uint16 [12]
  SIGNAL tmp_27                           : std_logic_vector(0 TO 16200);  -- ufix1 [16201]
  SIGNAL tmp_28                           : std_logic_vector(0 TO 16200);  -- ufix1 [16201]
  SIGNAL tmp_29                           : std_logic_vector(0 TO 16200);  -- ufix1 [16201]
  SIGNAL parity_bits                      : std_logic_vector(0 TO 16200);  -- ufix1 [16201]
  SIGNAL parity_bits_1                    : std_logic_vector(0 TO 16200);  -- ufix1 [16201]
  SIGNAL parity_bits_2                    : std_logic_vector(0 TO 16200);  -- ufix1 [16201]
  SIGNAL parity_bits_3                    : std_logic_vector(0 TO 16200);  -- ufix1 [16201]
  SIGNAL parity_bits_4                    : std_logic_vector(0 TO 16200);  -- ufix1 [16201]
  SIGNAL tmp_30                           : std_logic_vector(0 TO 16200);  -- ufix1 [16201]
  SIGNAL tmp_31                           : std_logic_vector(0 TO 16200);  -- ufix1 [16201]
  SIGNAL tmp_33                           : std_logic;  -- ufix1
  SIGNAL serial_out_1                     : std_logic;  -- ufix1
  SIGNAL tmp_35                           : std_logic;  -- ufix1
  SIGNAL serial_out_2                     : std_logic;  -- ufix1
  SIGNAL tmp_38                           : std_logic;  -- ufix1
  SIGNAL valid_1                          : std_logic;  -- ufix1

BEGIN
  tmp <= to_unsigned(16#0#, 2);

  tmp_1 <= to_unsigned(16#0#, 2);

  tmp_2 <= to_unsigned(16#0#, 2);

  tmp_3 <= to_unsigned(16#0#, 2);

  tmp_4 <= to_unsigned(16#0#, 2);

  tmp_5 <= to_unsigned(16#0#, 2);

  tmp_6 <= to_unsigned(16#0#, 2);

  tmp_7 <= to_unsigned(16#0#, 2);

  -- HDL code generation from MATLAB function: sf_gateway_fsm_select_xor
  tmp_8 <= to_unsigned(16#0#, 2);

  tmp_9 <= to_unsigned(16#0000#, 16);

  tmp_10 <= to_unsigned(16#0000#, 16);

  tmp_11 <= to_unsigned(16#0000#, 16);

  counter <= to_unsigned(16#0000#, 16);

  counter_1 <= to_unsigned(16#0000#, 16);

  counter_2 <= to_unsigned(16#0000#, 16);

  p13_output : PROCESS (counter, counter_1, counter_2, tmp_12, tmp_13)
    VARIABLE counter1 : unsigned(15 DOWNTO 0);
  BEGIN
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        counter1 := counter_1;
      WHEN "00000000000000000000000000000000" =>
        counter1 := counter_2;
      WHEN "00000000000000000000000000000001" =>
        counter1 := tmp_13;
      WHEN OTHERS => 
        counter1 := counter;
    END CASE;
    counter_3 <= counter1;
  END PROCESS p13_output;


  tmp_14 <= counter_4 + to_unsigned(16#0001#, 16);

  p18_output : PROCESS (counter_4, enable, tmp_10, tmp_11, tmp_12, tmp_14, tmp_9)
    VARIABLE tmp15 : unsigned(15 DOWNTO 0);
    VARIABLE tmp_0 : unsigned(15 DOWNTO 0);
  BEGIN
    tmp15 := to_unsigned(16#0000#, 16);
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        tmp_0 := tmp_10;
      WHEN "00000000000000000000000000000000" =>
        IF enable = '1' THEN 
          tmp15 := tmp_14;
        ELSE 
          tmp15 := counter_4;
        END IF;
        tmp_0 := tmp15;
      WHEN "00000000000000000000000000000001" =>
        tmp_0 := tmp_11;
      WHEN OTHERS => 
        tmp_0 := tmp_9;
    END CASE;
    tmp_16 <= tmp_0;
  END PROCESS p18_output;


  p7_output : PROCESS (counter_3, counter_4, tmp_12, tmp_16)
    VARIABLE tmp17 : unsigned(15 DOWNTO 0);
  BEGIN
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        tmp17 := counter_4;
      WHEN "00000000000000000000000000000000" =>
        tmp17 := tmp_16;
      WHEN "00000000000000000000000000000001" =>
        tmp17 := counter_3;
      WHEN OTHERS => 
        tmp17 := counter_4;
    END CASE;
    tmp_18 <= tmp17;
  END PROCESS p7_output;


  counter_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        counter_4 <= to_unsigned(16#0001#, 16);
      ELSIF enb = '1' THEN
        counter_4 <= tmp_18;
      END IF;
    END IF;
  END PROCESS counter_reg_process;


  tmp_13 <= counter_4 + to_unsigned(16#0001#, 16);

  p21_output : PROCESS (moore_state_machine, tmp_12, tmp_13, tmp_6, tmp_7, tmp_8)
    VARIABLE tmp19 : unsigned(1 DOWNTO 0);
    VARIABLE tmp_01 : unsigned(1 DOWNTO 0);
  BEGIN
    tmp19 := to_unsigned(16#0#, 2);
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        tmp_01 := tmp_7;
      WHEN "00000000000000000000000000000000" =>
        tmp_01 := tmp_8;
      WHEN "00000000000000000000000000000001" =>
        IF tmp_13 > to_unsigned(16#3F48#, 16) THEN 
          tmp19 := to_unsigned(16#0#, 2);
        ELSE 
          tmp19 := moore_state_machine;
        END IF;
        tmp_01 := tmp19;
      WHEN OTHERS => 
        tmp_01 := tmp_6;
    END CASE;
    tmp_20 <= tmp_01;
  END PROCESS p21_output;


  p20_output : PROCESS (enable, moore_state_machine, tmp_12, tmp_3, tmp_4, tmp_5)
    VARIABLE tmp21 : unsigned(1 DOWNTO 0);
    VARIABLE tmp_02 : unsigned(1 DOWNTO 0);
  BEGIN
    tmp21 := to_unsigned(16#0#, 2);
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        tmp_02 := tmp_4;
      WHEN "00000000000000000000000000000000" =>
        IF enable = '1' THEN 
          tmp21 := to_unsigned(16#1#, 2);
        ELSE 
          tmp21 := moore_state_machine;
        END IF;
        tmp_02 := tmp21;
      WHEN "00000000000000000000000000000001" =>
        tmp_02 := tmp_5;
      WHEN OTHERS => 
        tmp_02 := tmp_3;
    END CASE;
    tmp_22 <= tmp_02;
  END PROCESS p20_output;


  p16_output : PROCESS (moore_state_machine, start, tmp, tmp_1, tmp_12, tmp_2)
    VARIABLE tmp23 : unsigned(1 DOWNTO 0);
    VARIABLE tmp_03 : unsigned(1 DOWNTO 0);
  BEGIN
    tmp23 := to_unsigned(16#0#, 2);
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        IF start = '1' THEN 
          tmp23 := to_unsigned(16#0#, 2);
        ELSE 
          tmp23 := moore_state_machine;
        END IF;
        tmp_03 := tmp23;
      WHEN "00000000000000000000000000000000" =>
        tmp_03 := tmp_1;
      WHEN "00000000000000000000000000000001" =>
        tmp_03 := tmp_2;
      WHEN OTHERS => 
        tmp_03 := tmp;
    END CASE;
    tmp_24 <= tmp_03;
  END PROCESS p16_output;


  p5_output : PROCESS (moore_state_machine, tmp_12, tmp_20, tmp_22, tmp_24)
    VARIABLE tmp25 : unsigned(1 DOWNTO 0);
  BEGIN
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        tmp25 := tmp_24;
      WHEN "00000000000000000000000000000000" =>
        tmp25 := tmp_22;
      WHEN "00000000000000000000000000000001" =>
        tmp25 := tmp_20;
      WHEN OTHERS => 
        tmp25 := moore_state_machine;
    END CASE;
    tmp_26 <= tmp25;
  END PROCESS p5_output;


  moore_state_machine_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        moore_state_machine <= to_unsigned(16#2#, 2);
      ELSIF enb = '1' THEN
        moore_state_machine <= tmp_26;
      END IF;
    END IF;
  END PROCESS moore_state_machine_reg_process;


  -- MATLAB Function 'ldpc_encoder/fsm_select_xor'
  tmp_12 <= signed(resize(moore_state_machine, 32));

  outputgen: FOR k IN 0 TO 11 GENERATE
    addresses_unsigned(k) <= unsigned(addresses(k));
  END GENERATE;

  tmp_27 <= (OTHERS => '0');

  tmp_28 <= (OTHERS => '0');

  tmp_29 <= (OTHERS => '0');

  parity_bits <= (OTHERS => '0');

  parity_bits_1 <= (OTHERS => '0');

  parity_bits_2 <= (OTHERS => '0');

  p14_output : PROCESS (addresses_unsigned, input_bit, parity_bits, parity_bits_1, parity_bits_2,
       parity_bits_3, tmp_12)
    VARIABLE parity_bits1 : std_logic_vector(0 TO 16200);
    VARIABLE add_temp : vector_of_unsigned16(0 TO 11);
    VARIABLE sub_cast : vector_of_signed32(0 TO 11);
    VARIABLE add_temp_0 : vector_of_unsigned16(0 TO 11);
    VARIABLE sub_cast_0 : vector_of_signed32(0 TO 11);
    VARIABLE cast : vector_of_signed32(0 TO 11);
  BEGIN
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>

        FOR t_1 IN 0 TO 16200 LOOP
          parity_bits1(t_1) := parity_bits_1(t_1);
        END LOOP;

      WHEN "00000000000000000000000000000000" =>

        FOR t_2 IN 0 TO 16200 LOOP
          parity_bits1(t_2) := parity_bits_3(t_2);
        END LOOP;


        FOR add IN 0 TO 11 LOOP
          add_temp(add) := addresses_unsigned(add) + 1;
          sub_cast(add) := signed(resize(add_temp(add), 32));
          add_temp_0(add) := addresses_unsigned(add) + 1;
          sub_cast_0(add) := signed(resize(add_temp_0(add), 32));
          cast(add) := '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & input_bit;
          parity_bits1(to_integer(sub_cast(add) - 1)) := hdlcoder_to_stdlogic(hdlcoder_to_signed(parity_bits1(to_integer(sub_cast_0(add) - 1)) /= '0', 32) /= cast(add));
        END LOOP;

      WHEN "00000000000000000000000000000001" =>

        FOR t_3 IN 0 TO 16200 LOOP
          parity_bits1(t_3) := parity_bits_2(t_3);
        END LOOP;

      WHEN OTHERS => 

        FOR t_0 IN 0 TO 16200 LOOP
          parity_bits1(t_0) := parity_bits(t_0);
        END LOOP;

    END CASE;

    FOR t_4 IN 0 TO 16200 LOOP
      parity_bits_4(t_4) <= parity_bits1(t_4);
    END LOOP;

  END PROCESS p14_output;


  p15_output : PROCESS (addresses_unsigned, input_bit, parity_bits_3, start, tmp_12, tmp_27, tmp_28,
       tmp_29)
    VARIABLE parity_bits2 : std_logic_vector(0 TO 16200);
    VARIABLE add_temp1 : vector_of_unsigned16(0 TO 11);
    VARIABLE sub_cast1 : vector_of_signed32(0 TO 11);
    VARIABLE add_temp_01 : vector_of_unsigned16(0 TO 11);
    VARIABLE sub_cast_01 : vector_of_signed32(0 TO 11);
    VARIABLE cast1 : vector_of_signed32(0 TO 11);
  BEGIN
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        IF start = '1' THEN 

          FOR t_41 IN 0 TO 16200 LOOP
            parity_bits2(t_41) := parity_bits_3(t_41);
          END LOOP;


          FOR add1 IN 0 TO 11 LOOP
            add_temp1(add1) := addresses_unsigned(add1) + 1;
            sub_cast1(add1) := signed(resize(add_temp1(add1), 32));
            add_temp_01(add1) := addresses_unsigned(add1) + 1;
            sub_cast_01(add1) := signed(resize(add_temp_01(add1), 32));
            cast1(add1) := '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & input_bit;
            parity_bits2(to_integer(sub_cast1(add1) - 1)) := hdlcoder_to_stdlogic(hdlcoder_to_signed(parity_bits2(to_integer(sub_cast_01(add1) - 1)) /= '0', 32) /= cast1(add1));
          END LOOP;

        ELSE 

          FOR t_31 IN 0 TO 16200 LOOP
            parity_bits2(t_31) := parity_bits_3(t_31);
          END LOOP;

        END IF;
      WHEN "00000000000000000000000000000000" =>

        FOR t_11 IN 0 TO 16200 LOOP
          parity_bits2(t_11) := tmp_28(t_11);
        END LOOP;

      WHEN "00000000000000000000000000000001" =>

        FOR t_21 IN 0 TO 16200 LOOP
          parity_bits2(t_21) := tmp_29(t_21);
        END LOOP;

      WHEN OTHERS => 

        FOR t_01 IN 0 TO 16200 LOOP
          parity_bits2(t_01) := tmp_27(t_01);
        END LOOP;

    END CASE;

    FOR t_5 IN 0 TO 16200 LOOP
      tmp_30(t_5) <= parity_bits2(t_5);
    END LOOP;

  END PROCESS p15_output;


  p3_output : PROCESS (parity_bits_3, parity_bits_4, tmp_12, tmp_30)
  BEGIN
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        tmp_31 <= tmp_30;
      WHEN "00000000000000000000000000000000" =>
        tmp_31 <= parity_bits_4;
      WHEN "00000000000000000000000000000001" =>
        tmp_31 <= parity_bits_3;
      WHEN OTHERS => 
        tmp_31 <= parity_bits_3;
    END CASE;
  END PROCESS p3_output;


  parity_bits_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        parity_bits_3 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        parity_bits_3 <= tmp_31;
      END IF;
    END IF;
  END PROCESS parity_bits_reg_process;


  p19_output : PROCESS (addresses_unsigned, counter_4, enable, input_bit, parity_bits_3, tmp_12)
    VARIABLE parity_bits3 : std_logic_vector(0 TO 16200);
    VARIABLE tmp32 : std_logic;
    VARIABLE tmp_04 : std_logic;
    VARIABLE add_temp2 : vector_of_unsigned16(0 TO 11);
    VARIABLE sub_cast2 : vector_of_signed32(0 TO 11);
    VARIABLE add_temp_02 : vector_of_unsigned16(0 TO 11);
    VARIABLE sub_cast_02 : vector_of_signed32(0 TO 11);
    VARIABLE cast2 : vector_of_signed32(0 TO 11);
    VARIABLE sub_cast_1 : signed(31 DOWNTO 0);
  BEGIN
    tmp32 := '0';
    sub_cast_1 := to_signed(16#00000000#, 32);
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        tmp_04 := '0';
      WHEN "00000000000000000000000000000000" =>

        FOR t_02 IN 0 TO 16200 LOOP
          parity_bits3(t_02) := parity_bits_3(t_02);
        END LOOP;


        FOR add2 IN 0 TO 11 LOOP
          add_temp2(add2) := addresses_unsigned(add2) + 1;
          sub_cast2(add2) := signed(resize(add_temp2(add2), 32));
          add_temp_02(add2) := addresses_unsigned(add2) + 1;
          sub_cast_02(add2) := signed(resize(add_temp_02(add2), 32));
          cast2(add2) := '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & input_bit;
          parity_bits3(to_integer(sub_cast2(add2) - 1)) := hdlcoder_to_stdlogic(hdlcoder_to_signed(parity_bits3(to_integer(sub_cast_02(add2) - 1)) /= '0', 32) /= cast2(add2));
        END LOOP;

        IF enable = '1' THEN 
          sub_cast_1 := signed(resize(counter_4, 32));
          tmp32 := parity_bits3(to_integer(sub_cast_1 - 1));
        ELSE 
          tmp32 := '0';
        END IF;
        tmp_04 := tmp32;
      WHEN "00000000000000000000000000000001" =>
        tmp_04 := '0';
      WHEN OTHERS => 
        tmp_04 := '0';
    END CASE;
    tmp_33 <= tmp_04;
  END PROCESS p19_output;


  serial_out_1 <= '0';

  -- Repeat bit on all addresses
  p22_output : PROCESS (counter_4, parity_bits_3, tmp_12)
    VARIABLE tmp34 : std_logic;
    VARIABLE sub_cast3 : signed(31 DOWNTO 0);
  BEGIN
    sub_cast3 := to_signed(16#00000000#, 32);
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        tmp34 := '0';
      WHEN "00000000000000000000000000000000" =>
        tmp34 := '0';
      WHEN "00000000000000000000000000000001" =>
        sub_cast3 := signed(resize(counter_4, 32));
        tmp34 := parity_bits_3(to_integer(sub_cast3 - 1));
      WHEN OTHERS => 
        tmp34 := '0';
    END CASE;
    tmp_35 <= tmp34;
  END PROCESS p22_output;


  p12_output : PROCESS (tmp_12, tmp_35)
    VARIABLE serial_out1 : std_logic;
  BEGIN
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        serial_out1 := '0';
      WHEN "00000000000000000000000000000000" =>
        serial_out1 := '0';
      WHEN "00000000000000000000000000000001" =>
        serial_out1 := tmp_35;
      WHEN OTHERS => 
        serial_out1 := '0';
    END CASE;
    serial_out_2 <= serial_out1;
  END PROCESS p12_output;


  p9_output : PROCESS (serial_out_1, serial_out_2, tmp_12, tmp_33)
    VARIABLE tmp36 : std_logic;
  BEGIN
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        tmp36 := serial_out_1;
      WHEN "00000000000000000000000000000000" =>
        tmp36 := tmp_33;
      WHEN "00000000000000000000000000000001" =>
        tmp36 := serial_out_2;
      WHEN OTHERS => 
        tmp36 := '0';
    END CASE;
    serial_out <= tmp36;
  END PROCESS p9_output;


  -- Repeat bit on all addresses
  p17_output : PROCESS (enable, tmp_12)
    VARIABLE tmp37 : std_logic;
    VARIABLE tmp_05 : std_logic;
  BEGIN
    tmp37 := '0';
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        tmp_05 := '0';
      WHEN "00000000000000000000000000000000" =>
        IF enable = '1' THEN 
          tmp37 := '1';
        ELSE 
          tmp37 := '0';
        END IF;
        tmp_05 := tmp37;
      WHEN "00000000000000000000000000000001" =>
        tmp_05 := '0';
      WHEN OTHERS => 
        tmp_05 := '0';
    END CASE;
    tmp_38 <= tmp_05;
  END PROCESS p17_output;


  valid_1 <= '0';

  p8_output : PROCESS (tmp_12, tmp_38, valid_1)
    VARIABLE tmp39 : std_logic;
  BEGIN
    CASE tmp_12 IS
      WHEN "00000000000000000000000000000010" =>
        tmp39 := valid_1;
      WHEN "00000000000000000000000000000000" =>
        tmp39 := tmp_38;
      WHEN "00000000000000000000000000000001" =>
        tmp39 := '1';
      WHEN OTHERS => 
        tmp39 := '0';
    END CASE;
    valid <= tmp39;
  END PROCESS p8_output;


END rtl;

